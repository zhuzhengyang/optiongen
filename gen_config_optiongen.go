// Code generated by optiongen. DO NOT EDIT.
// optiongen: github.com/timestee/optiongen

package optiongen

import (
	"sync/atomic"
	"unsafe"
)

// Config should use NewTestConfig to initialize it
type Config struct {
	OptionPrefix         string `xconf:"option_prefix" usage:"option func name prefix, like: With, WithRedis"`                             // annotation@OptionPrefix(comment="option func name prefix, like: With, WithRedis")
	OptionWithStructName bool   `xconf:"option_with_struct_name" usage:"should the option func with struct name?"`                         // annotation@OptionWithStructName(comment="should the option func with struct name?")
	OptionReturnPrevious bool   `xconf:"option_return_previous" usage:"should option func return the previous ones?"`                      // annotation@OptionReturnPrevious(comment="should option func return the previous ones?")
	NewFunc              string `xconf:"new_func" usage:"new function name"`                                                               // annotation@NewFunc(comment="new function name")
	NewFuncReturn        string `xconf:"new_func_return" usage:"valid data: pointer,interface,visitor"`                                    // annotation@NewFuncReturn(comment="valid data: pointer,interface,visitor")
	Verbose              bool   `xconf:"v" usage:"Deprecated: use --debug instead"`                                                        // annotation@Verbose(xconf="v",comment="Deprecated: use --debug instead")
	UsageTagName         string `xconf:"usage_tag_name" usage:"usage tag name,if not empty,will gen usage support for xconf/xflag"`        // annotation@UsageTagName(comment="usage tag name,if not empty,will gen usage support for xconf/xflag")
	EmptyCompositeNil    bool   `xconf:"empty_composite_nil" usage:"should empty slice or map to be nil? otherwise will be make(XXXX,0)"`  // annotation@EmptyCompositeNil(comment="should empty slice or map to be nil? otherwise will be make(XXXX,0)")
	Debug                bool   `xconf:"debug" usage:"debug will print more detail info"`                                                  // annotation@Debug(comment="debug will print more detail info")
	XConf                bool   `xconf:"xconf" usage:"should gen xconf tag support?"`                                                      // annotation@XConf(xconf="xconf",comment="should gen xconf tag support?")
	XConfTrimPrefix      string `xconf:"x_conf_trim_prefix" usage:"if enable xconf tag, the tag value will trim prefix [XConfTrimPrefix]"` // annotation@XConfTrimPrefix(comment="if enable xconf tag, the tag value will trim prefix [XConfTrimPrefix]")
}

// ApplyOption apply mutiple new option and return the old ones
// sample:
// old := cc.ApplyOption(WithTimeout(time.Second))
// defer cc.ApplyOption(old...)
func (cc *Config) ApplyOption(opts ...ConfigOption) []ConfigOption {
	var previous []ConfigOption
	for _, opt := range opts {
		previous = append(previous, opt(cc))
	}
	return previous
}

// ConfigOption option func
type ConfigOption func(cc *Config) ConfigOption

// WithOptionPrefix option func name prefix, like: With, WithRedis
func WithOptionPrefix(v string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.OptionPrefix
		cc.OptionPrefix = v
		return WithOptionPrefix(previous)
	}
}

// WithOptionWithStructName should the option func with struct name?
func WithOptionWithStructName(v bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.OptionWithStructName
		cc.OptionWithStructName = v
		return WithOptionWithStructName(previous)
	}
}

// WithOptionReturnPrevious should option func return the previous ones?
func WithOptionReturnPrevious(v bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.OptionReturnPrevious
		cc.OptionReturnPrevious = v
		return WithOptionReturnPrevious(previous)
	}
}

// WithNewFunc new function name
func WithNewFunc(v string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.NewFunc
		cc.NewFunc = v
		return WithNewFunc(previous)
	}
}

// WithNewFuncReturn valid data: pointer,interface,visitor
func WithNewFuncReturn(v string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.NewFuncReturn
		cc.NewFuncReturn = v
		return WithNewFuncReturn(previous)
	}
}

// WithVerbose Deprecated: use --debug instead
func WithVerbose(v bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.Verbose
		cc.Verbose = v
		return WithVerbose(previous)
	}
}

// WithUsageTagName usage tag name,if not empty,will gen usage support for xconf/xflag
func WithUsageTagName(v string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.UsageTagName
		cc.UsageTagName = v
		return WithUsageTagName(previous)
	}
}

// WithEmptyCompositeNil should empty slice or map to be nil? otherwise will be make(XXXX,0)
func WithEmptyCompositeNil(v bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.EmptyCompositeNil
		cc.EmptyCompositeNil = v
		return WithEmptyCompositeNil(previous)
	}
}

// WithDebug debug will print more detail info
func WithDebug(v bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.Debug
		cc.Debug = v
		return WithDebug(previous)
	}
}

// WithXConf should gen xconf tag support?
func WithXConf(v bool) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.XConf
		cc.XConf = v
		return WithXConf(previous)
	}
}

// WithXConfTrimPrefix if enable xconf tag, the tag value will trim prefix [XConfTrimPrefix]
func WithXConfTrimPrefix(v string) ConfigOption {
	return func(cc *Config) ConfigOption {
		previous := cc.XConfTrimPrefix
		cc.XConfTrimPrefix = v
		return WithXConfTrimPrefix(previous)
	}
}

// NewTestConfig new Config
func NewTestConfig(opts ...ConfigOption) *Config {
	cc := newDefaultConfig()
	for _, opt := range opts {
		opt(cc)
	}
	if watchDogConfig != nil {
		watchDogConfig(cc)
	}
	return cc
}

// InstallConfigWatchDog the installed func will called when NewTestConfig  called
func InstallConfigWatchDog(dog func(cc *Config)) { watchDogConfig = dog }

// watchDogConfig global watch dog
var watchDogConfig func(cc *Config)

// newDefaultConfig new default Config
func newDefaultConfig() *Config {
	cc := &Config{}

	for _, opt := range [...]ConfigOption{
		WithOptionPrefix(""),
		WithOptionWithStructName(false),
		WithOptionReturnPrevious(true),
		WithNewFunc(""),
		WithNewFuncReturn(NewFuncReturnPointer),
		WithVerbose(false),
		WithUsageTagName(""),
		WithEmptyCompositeNil(false),
		WithDebug(false),
		WithXConf(false),
		WithXConfTrimPrefix(""),
	} {
		opt(cc)
	}

	return cc
}

// AtomicSetFunc used for XConf
func (cc *Config) AtomicSetFunc() func(interface{}) { return AtomicConfigSet }

// atomicConfig global *Config holder
var atomicConfig unsafe.Pointer

// onAtomicConfigSet global call back when  AtomicConfigSet called by XConf.
// use ConfigInterface.ApplyOption to modify the updated cc
// if passed in cc not valid, then return false, cc will not set to atomicConfig
var onAtomicConfigSet func(cc ConfigInterface) bool

// InstallCallbackOnAtomicConfigSet install callback
func InstallCallbackOnAtomicConfigSet(callback func(cc ConfigInterface) bool) {
	onAtomicConfigSet = callback
}

// AtomicConfigSet atomic setter for *Config
func AtomicConfigSet(update interface{}) {
	cc := update.(*Config)
	if onAtomicConfigSet != nil && !onAtomicConfigSet(cc) {
		return
	}
	atomic.StorePointer(&atomicConfig, (unsafe.Pointer)(cc))
}

// AtomicConfig return atomic *ConfigVisitor
func AtomicConfig() ConfigVisitor {
	current := (*Config)(atomic.LoadPointer(&atomicConfig))
	if current == nil {
		defaultOne := newDefaultConfig()
		if watchDogConfig != nil {
			watchDogConfig(defaultOne)
		}
		atomic.CompareAndSwapPointer(&atomicConfig, nil, (unsafe.Pointer)(defaultOne))
		return (*Config)(atomic.LoadPointer(&atomicConfig))
	}
	return current
}

// all getter func
func (cc *Config) GetOptionPrefix() string       { return cc.OptionPrefix }
func (cc *Config) GetOptionWithStructName() bool { return cc.OptionWithStructName }
func (cc *Config) GetOptionReturnPrevious() bool { return cc.OptionReturnPrevious }
func (cc *Config) GetNewFunc() string            { return cc.NewFunc }
func (cc *Config) GetNewFuncReturn() string      { return cc.NewFuncReturn }
func (cc *Config) GetVerbose() bool              { return cc.Verbose }
func (cc *Config) GetUsageTagName() string       { return cc.UsageTagName }
func (cc *Config) GetEmptyCompositeNil() bool    { return cc.EmptyCompositeNil }
func (cc *Config) GetDebug() bool                { return cc.Debug }
func (cc *Config) GetXConf() bool                { return cc.XConf }
func (cc *Config) GetXConfTrimPrefix() string    { return cc.XConfTrimPrefix }

// ConfigVisitor visitor interface for Config
type ConfigVisitor interface {
	GetOptionPrefix() string
	GetOptionWithStructName() bool
	GetOptionReturnPrevious() bool
	GetNewFunc() string
	GetNewFuncReturn() string
	GetVerbose() bool
	GetUsageTagName() string
	GetEmptyCompositeNil() bool
	GetDebug() bool
	GetXConf() bool
	GetXConfTrimPrefix() string
}

// ConfigInterface visitor + ApplyOption interface for Config
type ConfigInterface interface {
	ConfigVisitor
	ApplyOption(...ConfigOption) []ConfigOption
}
